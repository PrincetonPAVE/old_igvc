#include "ipc.h"
#include "Common.h"
//#include "Navigation.h"
#include "CostMap.h"
#include "wykobi.hpp"
#include <cmath>
#include "GPSTransforms.h"
#include <iostream>
#include <fstream>
#include "Point2D.h"

#include "commandArgs.h"
#include "definitions.h"
#include "Data.h"

#include "Polynomial.h"

using namespace Pave_Libraries_Common;
using namespace Pave_Libraries_Navigation;
using namespace Pave_Libraries_GPSTransforms;
using namespace Pave_Libraries_Geometry;

struct stereomapData
{
	//int passID;
	//bool obstructed;
	//bool inView;
	int segment;
	double distance;
	double angle;
};

bool generateWaypoints;
int passID = 0;
CostMap *costmap, *persistentmap;
CostMap *stereomap;
CostMapType cmUpdate;

stereomapData *stereomapStuff;
StateEstimationType state;

wykobi::point2d<> currentPosition, newPoint, waypoint;

double heading;

double *firstInRow;
double *secondFirstInRow;
double *secondLastInRow;
double *lastInRow;
double closestBlocked[SEGMENTS]; // distance to the closest obstacle in each segment... everything closer is "clear"

vector<double> updateXs, updateYs, updateCosts, boundaryXs, boundaryYs;

class Lane
{
public:
	unsigned int id, index, startIndex, endIndex;
	wykobi::point2d<> start, end, robotPosition;
	double heading;
	double confidence; // from detection
	double leftNiceness, rightNiceness;
	bool generated; // autogenerated sentinel value if true
	
	void print(char *message = NULL)
	{
		if (!message) message = "Lane";
		fprintf(stdout, "%s %d: from (%f, %f) to (%f, %f) heading %f confidence %f niceness %f %f\n",
			message, id, start.x, start.y, end.x, end.y, heading, confidence, leftNiceness, rightNiceness);
	}
};
vector<Lane> currentLanes, leftLaneHistory, rightLaneHistory;

bool receivedStateEst = false;

commandArgs *args;

double calculateNiceness(Lane lane, vector<Lane> history)
{
	if (history.size() == 0) return 0;
	/*wykobi::segment2d segment, oldSegment;
	segment[0] = lane.start;
	segment[1] = lane.end;*/
	wykobi::line2d oldLine;
	// Calculate niceness value
	// TODO: calibrate constants for decreasing the niceness, and also for decay based on oldness
	double niceness = 0;
	for (int h = 0; h < history.size(); h++)
	{
		Lane oldLane = history[h];
		oldLine[0] = oldLane.start;
		oldLine[1] = oldLane.end;
		//Niceness components of form a(bx)^c
		double distance = wykobi::min2imum_distance_from_point_to_line(lane.start, oldLine);
		niceness -= distance;
		//niceness -= pow(NICENESS_MAX_OFFSET*(h+1),-NICENESS_OFFSET_POWER) * pow(, NICENESS_OFFSET_POWER);
		double heading1 = lane.heading > wykobi::PI ? lane.heading - 2*wykobi::PI : lane.heading;
		double heading2 = oldLane.heading > wykobi::PI ? oldLane.heading - 2*wykobi::PI : oldLane.heading;
		double diffheading = fabs(heading1 - heading2);
		niceness -= diffheading;
		//niceness -= pow(NICENESS_MAX_ANGLE*(h+1),-NICENESS_ANGLE_POWER) * pow(diffheading, NICENESS_ANGLE_POWER);
		//if (h==0)
			//niceness /= wykobi::distance(lane.robotPosition, oldLane.robotPosition);
	}
	
	return niceness;
}

void initializeStereoMap()
{
	// So yeah, this could be done a lot more efficiently with trig... but it works, and you'd need something similar for the lower part of the FOV anyways
	int size = (int)((double)(Y_MAX - Y_MIN)/(double)STEREO_Y_UNITSIZE) + 1;
	firstInRow = (double*)calloc(size, sizeof(double));
	secondFirstInRow = (double*)calloc(size, sizeof(double));
	secondLastInRow = (double*)calloc(size, sizeof(double));
	lastInRow = (double*)calloc(size, sizeof(double));
	stereomap = new CostMap(STEREO_X_MIN, STEREO_X_MAX, STEREO_Y_MIN, STEREO_Y_MAX, STEREO_X_UNITSIZE, STEREO_Y_UNITSIZE);
	stereomapStuff = (stereomapData*)calloc(stereomap->getArraySize(), sizeof(stereomapData));

	bool foundFirstInRow;
	bool endedFirstInRow;
	bool foundSecondInRow;
	bool endedSecondInRow;
	double theta, distance;
	double segmentSize = (double)FOV / (double)SEGMENTS;
	int segment;
	int index;

	for(double y = STEREO_Y_MIN; y <= STEREO_Y_MAX + .0001; y += STEREO_Y_UNITSIZE)
	{
		foundFirstInRow = false;
		foundSecondInRow = false;
		endedFirstInRow = false;
		endedSecondInRow = false;
		for(double x  = STEREO_X_MIN; x <= STEREO_X_MAX + .0001; x += STEREO_X_UNITSIZE)
		{
			if(endedFirstInRow && endedSecondInRow)
				continue;
			theta = wykobi::vertex_angle(x, y, 0.0, 0.0, 0.0, 1.0);
			theta = abs(theta); // unnecessary
			distance = wykobi::distance(x, y, 0.0, 0.0);
			if(theta > FOV / 2.0 || distance < MINIMUM_RANGE || distance > STEREO_Y_MAX)
			{
				if(foundFirstInRow && !endedFirstInRow)
				{
					endedFirstInRow = true;
					lastInRow[stereomap->arrayY(y)] = x;
				}
				else if(foundSecondInRow && !endedSecondInRow)
				{
					endedSecondInRow = true;
					secondLastInRow[stereomap->arrayY(y)] = x;
				}
			}
			else
			{
				if(x < 0)
					theta *= -1;
				segment = (int)(theta/segmentSize + SEGMENTS/2.0);
				index = stereomap->getArrayIndex(x, y);
				stereomapStuff[index].segment = segment;
				stereomapStuff[index].angle = theta;
				stereomapStuff[index].distance = distance;
				if(!foundFirstInRow)
				{
					foundFirstInRow = true;
					firstInRow[stereomap->arrayY(y)] = x;
				}
				else if(endedFirstInRow && !foundSecondInRow)
				{
					foundSecondInRow = true;
					secondFirstInRow[stereomap->arrayY(y)] = x;
				}
			}
		}
	}

}

void translateToNewPoint(double x, double y)
{
    // Translate and rotate
	newPoint.x = x + currentPosition.x;
	newPoint.y = y + currentPosition.y;
	newPoint = wykobi::rotate(heading, newPoint, currentPosition);
}

bool updateCostMap(double x, double y, double cost)
{
	if(!costmap->boundsCheck(x, y))
		return false;
	
	if(persistentmap->get(x, y) > .0001)
		return false;
	
	if(!args->generateWaypoints)
    {
        //If the obstacle/lane is near the current waypoint, ignore it.
        //We define this as the square around the waypoint whose side is twice WAYPOINT_RADIUS_TO_CLEAR
        //The default waypoint is (0,0), so even if no waypoint has been acquired it works.
//2010 DEBUG
		//if (abs(waypoint.x - newPoint.x) <= WAYPOINT_RADIUS_TO_CLEAR && 
        //   abs(waypoint.y - newPoint.y) <= WAYPOINT_RADIUS_TO_CLEAR)
        //   return false;
    }
	
	// Adjust the cost
	int passWhenLastUpdated = 0;
	double old = costmap->get(x, y, (void**)&passWhenLastUpdated);
	
	if(passWhenLastUpdated == passID)
	{
		// We've already updated this point, so don't decrease the cost, just add more.
		costmap->set(x, y, min(old + LEARNING_RATE * cost, MAX_COST));
	}
	else
	{
		costmap->set(x, y, min((1 - LEARNING_RATE) * old + LEARNING_RATE * cost, MAX_COST));
		costmap->set(x, y, (void*)passID);
		// Since the cell hasn't been updated, add it
		updateXs.push_back(x);
		updateYs.push_back(y);
	}
	
	return true;
}

void updateCostMapFromStereoMapPoint(double x, double y)
{
	double stereoval = stereomap->get(x, y);
	//int arrayY = stereomap->arrayY(y);
	int index = stereomap->getArrayIndex(x, y);
	int segment = stereomapStuff[index].segment;
	double distance = stereomapStuff[index].distance;
	// If it's not an obstacle and above the blockage, do nothing
	if(stereoval < .5 && closestBlocked[segment] >= 0 && closestBlocked[segment] < distance)//< arrayY)
		return;

	translateToNewPoint(x,y);
	
	updateCostMap(newPoint.x, newPoint.y, stereoval);
}

inline void SWAP(int &x, int &y)
{
	int temp = y;
	y = x;
	x = temp;
}

int drawLineInCostMap(wykobi::point2d<> start, wykobi::point2d<> end, double cost, bool persist)
{
	if (!costmap->boundsCheck(start.x, start.y) || !costmap->boundsCheck(end.x, end.y))
		return 0;
	int x0 = costmap->arrayX(start.x), y0 = costmap->arrayY(start.y);
	int x1 = costmap->arrayX(end.x), y1 = costmap->arrayY(end.y);
	int count = 0;
	//Bresenham's Line Algorithm from Wikipedia
	int Dx = x1 - x0; 
	int Dy = y1 - y0;
	bool steep = (abs(Dy) >= abs(Dx));
	if (steep) {
		SWAP(x0, y0);
		SWAP(x1, y1);
		// recompute Dx, Dy after swap
		Dx = x1 - x0;
		Dy = y1 - y0;
	}
	int xstep = 1;
	if (Dx < 0) {
		xstep = -1;
		Dx = -Dx;
	}
	int ystep = 1;
	if (Dy < 0) {
		ystep = -1;		
		Dy = -Dy; 
	}
	int TwoDy = 2*Dy; 
	int TwoDyTwoDx = TwoDy - 2*Dx; // 2*Dy - 2*Dx
	int E = TwoDy - Dx; //2*Dy - Dx
	int y = y0;
	int xDraw, yDraw;	
	for (int x = x0; x != x1; x += xstep) {		
		if (steep) {			
			xDraw = y;
			yDraw = x;
		} else {			
			xDraw = x;
			yDraw = y;
		}
		// plot
		int pass;
		costmap->getCell(xDraw, yDraw, (void**)&pass);
		costmap->setCell(xDraw, yDraw, cost);
		if (pass != passID)
		{
			count++;
			costmap->setCell(xDraw, yDraw, (void*)passID);
			double xOut = costmap->getXMin() + costmap->getXUnitSize() * xDraw;
			double yOut = costmap->getYMin() + costmap->getYUnitSize() * yDraw;
			//printf("%d\t%d\t->\t%f\t%f\t\n",xDraw,yDraw,xOut,yOut);
			updateXs.push_back(xOut);
			updateYs.push_back(yOut);
		}
		if (persist)
		{
			//Persisted points are not overwritten by stereomap updates.
			persistentmap->setCell(xDraw, yDraw, cost);
			double xOut = costmap->getXMin() + costmap->getXUnitSize() * xDraw;
			double yOut = costmap->getYMin() + costmap->getYUnitSize() * yDraw;
			boundaryXs.push_back(xOut);
			boundaryYs.push_back(yOut);
			// and these will be put out at the end of StereoUpdate
		}
		// next
		if (E > 0) {
		    E += TwoDyTwoDx; //E += 2*Dy - 2*Dx;
		    y = y + ystep;
		} else {
		    E += TwoDy; //E += 2*Dy;
		}
	}
	return count;
}

void initializeLaneHistory()
{
	// TODO: We need to make sure that GPS is valid, 
	// because if heading is screwy then lane detection, without a doubt, WILL FAIL...
	
	// We assume that the robot starts in the center of the lane, pointing parallel to the lane.
	// If it starts out in the middle of a turn, this might fail.
	// If so, we would want to decrease LANE_EXTENT_TO_ESTIMATE
	bool success;
	/*
	LANE_HISTORY_COUNT = Data::getInt("LaneHistoryCount", success);
	NICENESS_THRESHOLD = Data::getDouble("LaneNicenessThreshold", success);
	LANE_EXTENT = Data::getDouble("LaneExtent", success);
	LANE_BACK_EXTENT = Data::getDouble("LaneBackExtent", success);
	LANE_WIDTH = Data::getDouble("LaneWidth", success);
	LANE_EXTRAPOLATE_FACTOR = Data::getDouble("LaneExtrapolateFactor", success);
	WAYPOINT_EXTENT = Data::getDouble("WaypointExtent", success);
	*/

	/*
	if (WAYPOINT_EXTENT > .0001)
	{
		translateToNewPoint(0, WAYPOINT_EXTENT);
		waypoint = wykobi::point2d<>(newPoint);
	}
	*/

	/*
	Lane left, right;
	left.generated = right.generated = true;
	left.heading = right.heading = heading;
	translateToNewPoint(-LANE_WIDTH/2, -LANE_BACK_EXTENT); left.start.x = newPoint.x; left.start.y = newPoint.y;
	translateToNewPoint(LANE_WIDTH/2, -LANE_BACK_EXTENT); right.start.x = newPoint.x; right.start.y = newPoint.y;
	translateToNewPoint(-LANE_WIDTH/2, LANE_EXTENT); left.end.x = newPoint.x; left.end.y = newPoint.y;
	translateToNewPoint(LANE_WIDTH/2, LANE_EXTENT); right.end.x = newPoint.x; right.end.y = newPoint.y;
	leftLaneHistory.assign(LANE_HISTORY_COUNT, left);
	rightLaneHistory.assign(LANE_HISTORY_COUNT, right);
	drawLineInCostMap(left.start, left.end, LANE_ADDED_COST, true);
	drawLineInCostMap(right.start, right.end, LANE_ADDED_COST, true);
	
	wykobi::point2d<> cap0, cap1;
	translateToNewPoint(-LANE_WIDTH, -LANE_BACK_EXTENT); cap0.x = newPoint.x; cap0.y = newPoint.y;
	translateToNewPoint(LANE_WIDTH, -LANE_BACK_EXTENT); cap1.x = newPoint.x; cap1.y = newPoint.y;
	drawLineInCostMap(cap0, cap1, BOUNDARY_COST, true);
	*/
}

bool initializeBoundaries()
{
	bool success = false;
	char *boundaryFileName = Data::getString("Boundary_File", success);
	if(success)
	{
		vector<double> latitudes, longitudes;
		std::string line;
		std::ifstream boundaryFile(boundaryFileName);
		if(!boundaryFile.is_open())
			return false;
		while(!boundaryFile.eof())
		{
			std::getline(boundaryFile, line);
			longitudes.push_back(atof(line.c_str()));
			if(boundaryFile.eof())
			{
				longitudes.pop_back();
				break;
			}
			getline(boundaryFile, line);
			latitudes.push_back(atof(line.c_str()));
		}
		for(int i = 0; i < (int)latitudes.size(); i++)
		{
			CartesianLocalPoint p = GPSTransforms::ConvertToLocal(GeodeticPoint(latitudes[i], longitudes[i]));
			latitudes[i] = p.X;
			longitudes[i] = p.Y;
		}
		
		for(int i = 0; i < latitudes.size(); i++)
		{
			/*
			double distance = wykobi::distance(latitudes[i], longitudes[i], latitudes[i+1], longitudes[i+1]);
			double numCells = distance / X_UNIT_SIZE;
			int numCellsI = (int)numCells;
			for(int j = 0; j <= numCellsI; j++)
			{
				double xCoord = latitudes[i] + (latitudes[i+1] - latitudes[i]) * (j / numCells);
				double yCoord = longitudes[i] + (longitudes[i+1] - longitudes[i]) * (j / numCells);
				boundaryXs.push_back(xCoord);
				boundaryYs.push_back(yCoord);
			}
			*/
			wykobi::point2d<> start, end;
			start.x = latitudes[i]; start.y = longitudes[i];
			end.x = latitudes[i+1==latitudes.size() ? 0 : i+1];
			end.y = longitudes[i+1==latitudes.size() ? 0 : i+1];
			cout << drawLineInCostMap(start, end, BOUNDARY_COST, true) << endl;
		}
		/*
		if(latitudes.size() > 2)
		{
			double distance = wykobi::distance(latitudes[latitudes.size() - 1], longitudes[latitudes.size() - 1], latitudes[0], longitudes[0]);
			double numCells = distance / X_UNIT_SIZE;
			int numCellsI = (int)numCells;
			for(int j = 0; j <= numCellsI; j++)
			{
				double xCoord = latitudes[latitudes.size() - 1] + (latitudes[0] - latitudes[latitudes.size() - 1]) * (j / numCells);
				double yCoord = longitudes[latitudes.size() - 1] + (longitudes[0] - longitudes[latitudes.size() - 1]) * (j / numCells);
				boundaryXs.push_back(xCoord);
				boundaryYs.push_back(yCoord);
			}
		}
		*/
		return true;
	}
	else return false;
}

void WaypointUpdateHandler(void *data)
{
    SetWaypointsType waypoints = *((SetWaypointsType*)data);
    if (waypoints.numPoints > 0)
	{
		waypoint.x = waypoints.points[0].x;
		waypoint.y = waypoints.points[0].y;
	}
}

void processValidLane(Lane lane, vector<Lane> &history)
{
	//Push onto vector as shift register
	for (int i = 1; i < history.size(); i++) history[i] = history[i-1];
	history[0] = lane;
	
	//Draw and persist the line.
	drawLineInCostMap(lane.start, lane.end, LANE_ADDED_COST, false);
	
	//Nonpersistent interpolation
	if(args->interpolateLanes && history.size() > 1)
		drawLineInCostMap(history[0].start, history[1].end, LANE_ADDED_COST, false);
	
	//Nonpersistent extrapolation
	/*
	if(args->extrapolate)
	{
		wykobi::point2d<> extra;
		//From wykobi::generate_point_on_ray
		extra.x = lane.start.x + LANE_EXTRAPOLATE_FACTOR * lane.end.x;
		extra.y = lane.start.y + LANE_EXTRAPOLATE_FACTOR * lane.end.y;
		drawLineInCostMap(lane.end, extra, LANE_ADDED_COST, false);
	}
	*/
}

void StereoUpdateHandler(void *data)
{
	passID++;
	VisionUpdateType *update = (VisionUpdateType*)data;
	
	state = update->state;
	currentPosition.x = state.Easting;
	currentPosition.y = state.Northing;
	heading = -state.Heading * wykobi::_180DivPI;
	
	updateXs.clear();
	updateYs.clear();
	updateCosts.clear();

	if(!receivedStateEst)
	{
		receivedStateEst = true;
		//good idea, but not yet synchronized with nav in current implementation
//		costmap = new CostMap(state.Easting + X_MIN, state.Easting + X_MAX, state.Northing + Y_MIN, state.Northing + Y_MAX, X_UNIT_SIZE, Y_UNIT_SIZE);
//		persistentmap = new CostMap(state.Easting + X_MIN, state.Easting + X_MAX, state.Northing + Y_MIN, state.Northing + Y_MAX, X_UNIT_SIZE, Y_UNIT_SIZE);
		costmap = new CostMap(X_MIN, X_MAX, Y_MIN, Y_MAX, X_UNIT_SIZE, Y_UNIT_SIZE);
		persistentmap = new CostMap(X_MIN, X_MAX, Y_MIN, Y_MAX, X_UNIT_SIZE, Y_UNIT_SIZE);
		
		
		cmUpdate.xMax = costmap->getXMax();
		cmUpdate.xMin = costmap->getXMin();
		cmUpdate.xUnitSize = costmap->getXUnitSize();
		cmUpdate.yMax = costmap->getYMax();
		cmUpdate.yMin = costmap->getYMin();
		cmUpdate.yUnitSize = costmap->getYUnitSize();
		cout << "Received initial state estimation\n" << flush;
		cmUpdate.numPoints = 0;
		cmUpdate.xUpdates = NULL;
		cmUpdate.yUpdates = NULL;
		cmUpdate.costUpdates = NULL;
		//if (args->publish) 
			Messages::CostMap.publish(&cmUpdate);
		if(args->lanes) initializeLaneHistory();
		if(args->boundaries) initializeBoundaries();
	}

	double cost;
	void *stored;
	double stereomapval;
	int stuffIndex;

	// Clear out the segments
	for(int i = 0; i < SEGMENTS; i++)
		closestBlocked[i] = CLEAR_DISTANCE;

	// Clear the stereomap... why?
	// because stereomap is directly from the new updates?
	stereomap->setAll(CLEAR_COST);

	// Handle detected obstacles (directly from Kratos, refactored)
	for(int i = 0; i < update->numPoints; i++)
	{
		// Locate in the stereo map
		if(!stereomap->boundsCheck(update->xVals[i], update->yVals[i]))
			continue;

		stereomapval = stereomap->get(update->xVals[i], update->yVals[i]);
		if(stereomapval < OBSTACLE_COST + .0000001)
			stereomap->set(update->xVals[i], update->yVals[i], OBSTACLE_COST);
		else
			stereomap->set(update->xVals[i], update->yVals[i], stereomapval + ADDED_COST);
		stuffIndex = stereomap->getArrayIndex(update->xVals[i], update->yVals[i]);
		if(closestBlocked[stereomapStuff[stuffIndex].segment] < 0 || stereomapStuff[stuffIndex].distance <  closestBlocked[stereomapStuff[stuffIndex].segment])
		//stereomap->arrayY(update->yVals[i]) < closestBlocked[stereomapStuff[stuffIndex].segment])
		{
			closestBlocked[stereomapStuff[stuffIndex].segment] = stereomapStuff[stuffIndex].distance;
			//stereomap->arrayY(update->yVals[i]);
		}
	}

//	// Handle lane points
//	// second condition should always be true
//	if(update->numLanes > 0 && update->numLanePoints == update->numLanes * 3)
//	{
//		// old functionality:
//		// Find right and left lanes
//		// If both, extend front, box back, send waypoint
//		// If one, extend front and back, infer other, send waypoint
//
//		for(int li = 0; li < update->numLanes; li++)
//		{
//			// read the endpoints and midpoint
//			float *xVals = update->LanexVals + li*3;
//			float *yVals = update->LaneyVals + li*3;
//			double xValsD[3], yValsD[3];
//			for(int i = 0; i < 3; i++) {
//				xValsD[i] = (double) xVals[i];
//				yValsD[i] = (double) yVals[i];
//			}
//			Polynomial<2> p = Polynomial<2>::findPoly(xValsD, yValsD);
//			p.setTheta(update->laneAngles[li]);
//			p.setMinX(xVals[0]);
//			p.setMaxX(xVals[2]);
//
//			for(int i = 0; i < 2 - 1; i++) {
//				double x1, y1, x2, y2;
//				p.evalRotated(xVals[i], x1, y1);
//				p.evalRotated(xVals[i + 1], x2, y2);
//				drawLineInCostMap(wykobi::point2d<>(x1, y1),
//								  wykobi::point2d<>(x2, y2),
//								  LANE_ADDED_COST, true);
//			}
//
///*			if(!stereomap->boundsCheck(update->LanexVals[i], update->LaneyVals[i]))
//				continue;
//			stereomapval = stereomap->get(update->LanexVals[i], update->LaneyVals[i]);
//			stereomap->set(update->LanexVals[i], update->LaneyVals[i], stereomapval + LANE_ADDED_COST);
//*/
//		}
//	}



/*
	// Handle lane points (new for 2009 using time filtering)
	Lane bestLeftLane, bestRightLane;
	if(args->lanes)
	{
		// Reduce the lanes from a set of points to a start, end, heading, and "niceness" factor
		// Niceness is like confidence, but in the context of recent left and right lane history.
		int i = 0;
		//Initialize currentLanes
		Lane defaultLane;
		defaultLane.generated = true;
		currentLanes.assign(update->numLanes, defaultLane);
		for(int current = 0; current < update->numLanes; current++)
		{
			Lane lane;
			lane.generated = false;
			lane.confidence = update->LaneConfidences[current];
			lane.robotPosition = wykobi::point2d<>(currentPosition);
			lane.id = current;
			lane.index = i;

			//Instead of using the reported closest and furthest points,
			//we use the closest and furthest points that make sense;
			//that is, masked by the stereo map.
			bool inBounds = false, outOfBounds = false;
			for(; i - lane.index < update->pointsPerLane[current]; i++)
			{
				if(stereomap->boundsCheck(update->LanexVals[i], update->LaneyVals[i]))
				{
					translateToNewPoint(update->LanexVals[i], update->LaneyVals[i]);
					if (!inBounds)
					{
						inBounds = true;
						lane.startIndex = i;
						lane.start = wykobi::point2d<>(newPoint);
					}
					lane.endIndex = i;
					lane.end = wykobi::point2d<>(newPoint);
					
					//Commented because we may only want to draw the best left and best right lane(s).
					//stereomapval = stereomap->get(update->LanexVals[i], update->LaneyVals[i]);
					//stereomap->set(update->LanexVals[i], update->LaneyVals[i], stereomapval + LANE_ADDED_COST);
				}
			}
			
			//Vertex angle in degrees, headings in radians, both CW from north
			lane.heading = wykobi::vertex_angle(lane.end.x, lane.end.y, lane.start.x, lane.start.y, lane.start.x, lane.start.y + 1.0) / wykobi::_180DivPI;
			
			// Calculate niceness value
			lane.leftNiceness = calculateNiceness(lane, leftLaneHistory);
			lane.rightNiceness = calculateNiceness(lane, rightLaneHistory);
			
			currentLanes[current] = lane;
			lane.print();

			drawLineInCostMap(lane.start, lane.end, LANE_ADDED_COST, false);
		}
		
		// Now choose the nicest left and right lane
		bestLeftLane.generated = true;
		bestRightLane.generated = true;
		for(int current = 0; current < update->numLanes; current++)
		{
			Lane lane = currentLanes[current];
			if ((bestLeftLane.generated || lane.leftNiceness > bestLeftLane.leftNiceness) && !lane.generated)
				bestLeftLane = lane;
			if ((bestRightLane.generated || lane.rightNiceness > bestRightLane.rightNiceness) && !lane.generated)
				bestRightLane = lane;
		}
		
		// Threshold since there might not even be a good one
		// If it's good, insert the lane's points, and also insert into the history
		if (!bestLeftLane.generated && bestLeftLane.leftNiceness > NICENESS_THRESHOLD)
		{
			Lane lane = bestLeftLane;
			lane.print("Best Left Lane");
			
			processValidLane(lane, leftLaneHistory);
			
			//Push onto vector as shift register
			vector<Lane> &v = leftLaneHistory;
			for (int i = 1; i < v.size(); i++) v[i] = v[i-1];
			v[0] = lane;
		}
		if (!bestRightLane.generated && bestRightLane.rightNiceness > NICENESS_THRESHOLD)
		{
			Lane lane = bestRightLane;
			lane.print("Best Right Lane");

			processValidLane(lane, rightLaneHistory);
		}
		
		// for (int h = 0; h < 2; h++)
		// 		{
		// 			vector<Lane> &v = h ? rightLaneHistory : leftLaneHistory;
		// 			for (int i = 0; i < v.size(); i++)
		// 			{
		// 				drawLineInCostMap(v[i].start, v[i].end, LANE_ADDED_COST);
		// 				if (args->interpolateLanes && i < v.size() - 1)
		// 				{
		// 					drawLineInCostMap(v[i].start , v[i+1].end, LANE_ADDED_COST);
		// 				}
		// 			}
		// 		}
		
		currentLanes.clear();
	} // endif detecting lanes
	*/
	
	for(double y = STEREO_Y_MIN; y <= STEREO_Y_MAX + .0001; y += STEREO_Y_UNITSIZE)
	{
		int arrayY = stereomap->arrayY(y);
		for(double x  = firstInRow[arrayY]; x < lastInRow[arrayY] - .0001; x += STEREO_X_UNITSIZE)
			updateCostMapFromStereoMapPoint(x, y);
		for(double x  = secondFirstInRow[arrayY]; x < secondLastInRow[arrayY] - .0001; x += STEREO_X_UNITSIZE)
			updateCostMapFromStereoMapPoint(x, y);
	}

	
	updateCosts.reserve(updateXs.size());
	for(int i = 0; i < (int)updateXs.size(); i++)
		updateCosts.push_back(costmap->get(updateXs[i], updateYs[i]));

	for(int i = 0; i < boundaryXs.size(); i++)
	{
		updateXs.push_back(boundaryXs[i]);
		updateYs.push_back(boundaryYs[i]);
		updateCosts.push_back(BOUNDARY_COST);
	}

	if(updateXs.size() > 0)
	{
		cmUpdate.numPoints = (int)updateXs.size();
		cmUpdate.xUpdates = &updateXs[0];
		cmUpdate.yUpdates = &updateYs[0];
		cmUpdate.costUpdates = &updateCosts[0];
		//if (args->publish) 
		{
			Messages::CostMap.publish(&cmUpdate);
			cout << "Published " << cmUpdate.numPoints << " points.\n" << flush;
		}
	}
	
	/*
	//Waypoint generation
	if (args->generateWaypoints && args->lanes && update->numLanePoints > 0 &&
		!bestLeftLane.generated && !bestRightLane.generated &&
		((bestLeftLane.leftNiceness > NICENESS_THRESHOLD && 
		bestRightLane.rightNiceness > NICENESS_THRESHOLD) ||
		wykobi::distance(currentPosition, waypoint) < WAYPOINT_GEN_DISTANCE))
    {
		double wpheading = (bestLeftLane.heading + bestRightLane.heading) / 2.0;
		newPoint.x = currentPosition.x;
		newPoint.y = currentPosition.y + WAYPOINT_EXTENT;
		wykobi::point2d<> wp = wykobi::rotate(wpheading, newPoint, currentPosition);
		bool reachable = true; // is the waypoint reachable?
		int waypointxindex = costmap->arrayX(wp.x);
		int waypointyindex = costmap->arrayY(wp.y);
		for (int i = -WAYPOINT_RADIUS_TO_CLEAR; i <= WAYPOINT_RADIUS_TO_CLEAR; i++)
		{
			for (int j = -WAYPOINT_RADIUS_TO_CLEAR; j <= WAYPOINT_RADIUS_TO_CLEAR; j++)
			{
				if (!costmap->boundsCheckByIndex(waypointxindex+i, waypointyindex+j) ||
					costmap->getCell(waypointxindex+i, waypointyindex+j) != CLEAR_COST)
				{
					reachable = false;
					printf("Waypoint (%f, %f) unreachable.\n", wp.x, wp.y);
					break;
				}
			}
		}
		
		if (reachable)
		{
			waypoint = wp;
			printf("Set waypoint (%f, %f).\n", waypoint.x, waypoint.y);
		}
    }
	if (args->generateWaypoints && args->publish)
	{
		SetWaypointsType Waypoints;
		Waypoints.numPoints = 1;
		Pave_Libraries_Common::point2d pt;
		pt.x = waypoint.x;
		pt.y = waypoint.y;
		Waypoints.points = &pt;
		Messages::SetWaypoints.publish(&Waypoints);
	}
	*/
}

void ClearCostMapHandler(void *data)
{
    costmap->setAll(CLEAR_COST);

	updateXs.clear();
	updateYs.clear();
	updateCosts.clear();

	if(args->boundaries) initializeBoundaries();
	
	updateCosts.reserve(updateXs.size());
	for(int i = 0; i < (int)updateXs.size(); i++)
		updateCosts.push_back(costmap->get(updateXs[i], updateYs[i]));

	for(int i = 0; i < boundaryXs.size(); i++)
	{
		updateXs.push_back(boundaryXs[i]);
		updateYs.push_back(boundaryYs[i]);
		updateCosts.push_back(BOUNDARY_COST);
	}

	if(updateXs.size() > 0)
	{
		cmUpdate.numPoints = (int)updateXs.size();
		cmUpdate.xUpdates = &updateXs[0];
		cmUpdate.yUpdates = &updateYs[0];
		cmUpdate.costUpdates = &updateCosts[0];
		//if (args->publish) 
		{
			Messages::CostMap.publish(&cmUpdate);
			cout << "Published " << cmUpdate.numPoints << " points.\n" << flush;
		}
	}
}

int main(int argc, char **argv)
{
	args = parseArgs(argc, argv);

	initializeStereoMap();
	IPCConnect("CostMapGenerator");
	Messages::VisionUpdate.subscribe(&StereoUpdateHandler, true, false);
    if (!args->generateWaypoints)
        Messages::SetWaypoints.subscribe(&WaypointUpdateHandler, true, false);
    Messages::ClearCostMap.subscribe(&ClearCostMapHandler, true, false);
	//Messages::StateEstimation.subscribe(&SEUpdateHandler, true, false);
	//Initial state estimation is now part of StereoUpdateHandler

	IPC_dispatch();
}