#include "ipc.h"
//#include "Messages.h"
#include "Common.h"
//#include "Navigation.h"
#include "CostMap.h"
#include "wykobi.hpp"
#include <cmath>
#include "GPSTransforms.h"
#include <iostream>
#include <fstream>
#include "Point2D.h"

#include "commandArgs.h"
#include "definitions.h"
#include "Data.h"

#include "Polynomial.h"

using namespace Pave_Libraries_Common;
using namespace Pave_Libraries_Navigation;
using namespace Pave_Libraries_GPSTransforms;
using namespace Pave_Libraries_Geometry;

struct stereomapData
{
	//int passID;
	//bool obstructed;
	//bool inView;
	int segment;
	double distance;
	double angle;
};

bool generateWaypoints;
int passID = 0;
CostMap *costmap, *persistentmap;
CostMap *stereomap;
CostMapType cmUpdate;

stereomapData *stereomapStuff;
StateEstimationType state;

wykobi::point2d<> currentPosition, newPoint, waypoint;

double heading;

double *firstInRow;
double *secondFirstInRow;
double *secondLastInRow;
double *lastInRow;
double closestBlocked[SEGMENTS]; // distance to the closest obstacle in each segment... everything closer is "clear"

vector<double> updateXs, updateYs, updateCosts, boundaryXs, boundaryYs;

vector<point2d> laneStartPt;
vector<point2d> laneEndPt;
//bool initialLaneDetected = false; /*obselete*/
point2d currLaneHeading;
//never used
/*
const double HEADING_CONTINUITY = 0.8;


class Lane
{
public:
	unsigned int id, index, startIndex, endIndex;
	wykobi::point2d<> start, end, robotPosition;
	double heading;
	double confidence; // from detection
	double leftNiceness, rightNiceness;
	bool generated; // autogenerated sentinel value if true
	
	void print(char *message = NULL)
	{
		if (!message) message = "Lane";
		fprintf(stdout, "%s %d: from (%f, %f) to (%f, %f) heading %f confidence %f niceness %f %f\n",
			message, id, start.x, start.y, end.x, end.y, heading, confidence, leftNiceness, rightNiceness);
	}
};
vector<Lane> currentLanes, leftLaneHistory, rightLaneHistory;
*/
bool receivedStateEst = false;

commandArgs *args;
//never called by anything
/*
double calculateNiceness(Lane lane, vector<Lane> history)
{
	if (history.size() == 0) return 0;
	//wykobi::segment2d segment, oldSegment;
	//segment[0] = lane.start;
	//segment[1] = lane.end;
	wykobi::line2d oldLine;
	// Calculate niceness value
	// TODO: calibrate constants for decreasing the niceness, and also for decay based on oldness
	double niceness = 0;
	for (int h = 0; h < history.size(); h++)
	{
		Lane oldLane = history[h];
		oldLine[0] = oldLane.start;
		oldLine[1] = oldLane.end;
		//Niceness components of form a(bx)^c
		double distance = wykobi::min2imum_distance_from_point_to_line(lane.start, oldLine);
		niceness -= distance;
		//niceness -= pow(NICENESS_MAX_OFFSET*(h+1),-NICENESS_OFFSET_POWER) * pow(, NICENESS_OFFSET_POWER);
		double heading1 = lane.heading > wykobi::PI ? lane.heading - 2*wykobi::PI : lane.heading;
		double heading2 = oldLane.heading > wykobi::PI ? oldLane.heading - 2*wykobi::PI : oldLane.heading;
		double diffheading = fabs(heading1 - heading2);
		niceness -= diffheading;
		//niceness -= pow(NICENESS_MAX_ANGLE*(h+1),-NICENESS_ANGLE_POWER) * pow(diffheading, NICENESS_ANGLE_POWER);
		//if (h==0)
			//niceness /= wykobi::distance(lane.robotPosition, oldLane.robotPosition);
	}
	
	return niceness;
}
*/
void initializeStereoMap()
{
	// So yeah, this could be done a lot more efficiently with trig... but it works, and you'd need something similar for the lower part of the FOV anyways
	int size = (int)((double)(Y_MAX - Y_MIN)/(double)STEREO_Y_UNITSIZE) + 1;
	firstInRow = (double*)calloc(size, sizeof(double));
	secondFirstInRow = (double*)calloc(size, sizeof(double));
	secondLastInRow = (double*)calloc(size, sizeof(double));
	lastInRow = (double*)calloc(size, sizeof(double));
	stereomap = new CostMap(STEREO_X_MIN, STEREO_X_MAX, STEREO_Y_MIN, STEREO_Y_MAX, STEREO_X_UNITSIZE, STEREO_Y_UNITSIZE);
	stereomapStuff = (stereomapData*)calloc(stereomap->getArraySize(), sizeof(stereomapData));

	bool foundFirstInRow;
	bool endedFirstInRow;
	bool foundSecondInRow;
	bool endedSecondInRow;
	double theta, distance;
	double segmentSize = (double)FOV / (double)SEGMENTS;
	int segment;
	int index;

	for(double y = STEREO_Y_MIN; y <= STEREO_Y_MAX + .0001; y += STEREO_Y_UNITSIZE)
	{
		foundFirstInRow = false;
		foundSecondInRow = false;
		endedFirstInRow = false;
		endedSecondInRow = false;
		for(double x  = STEREO_X_MIN; x <= STEREO_X_MAX + .0001; x += STEREO_X_UNITSIZE)
		{
			if(endedFirstInRow && endedSecondInRow)
				continue;
			theta = wykobi::vertex_angle(x, y, 0.0, 0.0, 0.0, 1.0);
			theta = abs(theta); // unnecessary
			distance = wykobi::distance(x, y, 0.0, 0.0);
			if(theta > FOV / 2.0 || distance < MINIMUM_RANGE || distance > STEREO_Y_MAX)
			{
				if(foundFirstInRow && !endedFirstInRow)
				{
					endedFirstInRow = true;
					lastInRow[stereomap->arrayY(y)] = x;
				}
				else if(foundSecondInRow && !endedSecondInRow)
				{
					endedSecondInRow = true;
					secondLastInRow[stereomap->arrayY(y)] = x;
				}
			}
			else
			{
				if(x < 0)
					theta *= -1;
				segment = (int)(theta/segmentSize + SEGMENTS/2.0);
				index = stereomap->getArrayIndex(x, y);
				stereomapStuff[index].segment = segment;
				stereomapStuff[index].angle = theta;
				stereomapStuff[index].distance = distance;
				if(!foundFirstInRow)
				{
					foundFirstInRow = true;
					firstInRow[stereomap->arrayY(y)] = x;
				}
				else if(endedFirstInRow && !foundSecondInRow)
				{
					foundSecondInRow = true;
					secondFirstInRow[stereomap->arrayY(y)] = x;
				}
			}
		}
	}

}

void translateToNewPoint(double x, double y)
{
    // Translate and rotate
	newPoint.x = x + currentPosition.x;
	newPoint.y = y + currentPosition.y;
	newPoint = wykobi::rotate(heading, newPoint, currentPosition);
}

/*obselete*/
/*
void translateToItself(double& x, double& y)
{
	wykobi::point2d<> pt(x, y);
	pt.x += currentPosition.x;
	pt.y += currentPosition.y;
	pt = wykobi::rotate(heading, pt, currentPosition); 
	
	//pt.x += -0.25;
	//pt.y += 0.03;
	//pt = wykobi::rotate(4.73, pt, currentPosition); 

	x = pt.x;
	y = pt.y;
}
*/

bool updateCostMap(double x, double y, double cost)
{
	if(!costmap->boundsCheck(x, y))
		return false;
	
	if(persistentmap->get(x, y) > .0001)
		return false;
	
	if(!args->generateWaypoints)
    {
        //If the obstacle/lane is near the current waypoint, ignore it.
        //We define this as the square around the waypoint whose side is twice WAYPOINT_RADIUS_TO_CLEAR
        //The default waypoint is (0,0), so even if no waypoint has been acquired it works.
        if (abs(waypoint.x - newPoint.x) <= WAYPOINT_RADIUS_TO_CLEAR && 
            abs(waypoint.y - newPoint.y) <= WAYPOINT_RADIUS_TO_CLEAR)
            return false;
    }
	
	// Adjust the cost
	int passWhenLastUpdated = 0;
	double old = costmap->get(x, y, (void**)&passWhenLastUpdated);
	
	if(passWhenLastUpdated == passID)
	{
		// We've already updated this point, so don't decrease the cost, just add more.
		costmap->set(x, y, min(old + LEARNING_RATE * cost, MAX_COST));
	}
	else
	{
		costmap->set(x, y, min((1 - LEARNING_RATE) * old + LEARNING_RATE * cost, MAX_COST));
		costmap->set(x, y, (void*)passID);
		// Since the cell hasn't been updated, add it
		updateXs.push_back(x);
		updateYs.push_back(y);
	}
	
	return true;
}

void updateCostMapFromStereoMapPoint(double x, double y)
{
	double stereoval = stereomap->get(x, y);
	//int arrayY = stereomap->arrayY(y);
	int index = stereomap->getArrayIndex(x, y);
	int segment = stereomapStuff[index].segment;
	double distance = stereomapStuff[index].distance;
	// If it's not an obstacle and above the blockage, do nothing
	if(stereoval < .5 && closestBlocked[segment] >= 0 && closestBlocked[segment] < distance)//< arrayY)
		return;

	translateToNewPoint(x,y);
	
	updateCostMap(newPoint.x, newPoint.y, stereoval);
}

inline void SWAP(int &x, int &y)
{
	int temp = y;
	y = x;
	x = temp;
}

int drawLine(CostMap& cm, wykobi::point2d<> start, wykobi::point2d<> end, double cost, bool persist)
{
	if (!cm.boundsCheck(start.x, start.y) || !cm.boundsCheck(end.x, end.y))
		return 0;
	int x0 = cm.arrayX(start.x), y0 = cm.arrayY(start.y);
	int x1 = cm.arrayX(end.x), y1 = cm.arrayY(end.y);
	int count = 0;
	//Bresenham's Line Algorithm from Wikipedia
	int Dx = x1 - x0; 
	int Dy = y1 - y0;
	bool steep = (abs(Dy) >= abs(Dx));
	if (steep) {
		SWAP(x0, y0);
		SWAP(x1, y1);
		// recompute Dx, Dy after swap
		Dx = x1 - x0;
		Dy = y1 - y0;
	}
	int xstep = 1;
	if (Dx < 0) {
		xstep = -1;
		Dx = -Dx;
	}
	int ystep = 1;
	if (Dy < 0) {
		ystep = -1;		
		Dy = -Dy; 
	}
	int TwoDy = 2*Dy; 
	int TwoDyTwoDx = TwoDy - 2*Dx; // 2*Dy - 2*Dx
	int E = TwoDy - Dx; //2*Dy - Dx
	int y = y0;
	int xDraw, yDraw;	
	for (int x = x0; x != x1; x += xstep) {		
		if (steep) {			
			xDraw = y;
			yDraw = x;
		} else {			
			xDraw = x;
			yDraw = y;
		}
		// plot
		int pass;
		cm.getCell(xDraw, yDraw, (void**)&pass);
		cm.setCell(xDraw, yDraw, cost);
		if (pass != passID)
		{
			count++;
			cm.setCell(xDraw, yDraw, (void*)passID);
			double xOut = cm.getXMin() + cm.getXUnitSize() * xDraw;
			double yOut = cm.getYMin() + cm.getYUnitSize() * yDraw;
			//printf("%d\t%d\t->\t%f\t%f\t\n",xDraw,yDraw,xOut,yOut);
			updateXs.push_back(xOut);
			updateYs.push_back(yOut);
		}
		if (persist)
		{
			//Persisted points are not overwritten by stereomap updates.
			persistentmap->setCell(xDraw, yDraw, cost);
			double xOut = costmap->getXMin() + costmap->getXUnitSize() * xDraw;
			double yOut = costmap->getYMin() + costmap->getYUnitSize() * yDraw;
			boundaryXs.push_back(xOut);
			boundaryYs.push_back(yOut);
			// and these will be put out at the end of StereoUpdate
		}
		// next
		if (E > 0) {
		    E += TwoDyTwoDx; //E += 2*Dy - 2*Dx;
		    y = y + ystep;
		} else {
		    E += TwoDy; //E += 2*Dy;
		}
	}
	return count;
}

int drawLineInCostMap(wykobi::point2d<> start, wykobi::point2d<> end, double cost, bool persist)
{
	return drawLine(*costmap, start, end, cost, persist);
}

void initializeLaneHistory()
{
	// TODO: We need to make sure that GPS is valid, 
	// because if heading is screwy then lane detection, without a doubt, WILL FAIL...
	
	// We assume that the robot starts in the center of the lane, pointing parallel to the lane.
	// If it starts out in the middle of a turn, this might fail.
	// If so, we would want to decrease LANE_EXTENT_TO_ESTIMATE
	bool success;
	/*
	LANE_HISTORY_COUNT = Data::getInt("LaneHistoryCount", success);
	NICENESS_THRESHOLD = Data::getDouble("LaneNicenessThreshold", success);
	LANE_EXTENT = Data::getDouble("LaneExtent", success);
	LANE_BACK_EXTENT = Data::getDouble("LaneBackExtent", success);
	LANE_WIDTH = Data::getDouble("LaneWidth", success);
	LANE_EXTRAPOLATE_FACTOR = Data::getDouble("LaneExtrapolateFactor", success);
	WAYPOINT_EXTENT = Data::getDouble("WaypointExtent", success);
	*/

	/*
	if (WAYPOINT_EXTENT > .0001)
	{
		translateToNewPoint(0, WAYPOINT_EXTENT);
		waypoint = wykobi::point2d<>(newPoint);
	}
	*/

	/*
	Lane left, right;
	left.generated = right.generated = true;
	left.heading = right.heading = heading;
	translateToNewPoint(-LANE_WIDTH/2, -LANE_BACK_EXTENT); left.start.x = newPoint.x; left.start.y = newPoint.y;
	translateToNewPoint(LANE_WIDTH/2, -LANE_BACK_EXTENT); right.start.x = newPoint.x; right.start.y = newPoint.y;
	translateToNewPoint(-LANE_WIDTH/2, LANE_EXTENT); left.end.x = newPoint.x; left.end.y = newPoint.y;
	translateToNewPoint(LANE_WIDTH/2, LANE_EXTENT); right.end.x = newPoint.x; right.end.y = newPoint.y;
	leftLaneHistory.assign(LANE_HISTORY_COUNT, left);
	rightLaneHistory.assign(LANE_HISTORY_COUNT, right);
	drawLineInCostMap(left.start, left.end, LANE_ADDED_COST, true);
	drawLineInCostMap(right.start, right.end, LANE_ADDED_COST, true);
	
	wykobi::point2d<> cap0, cap1;
	translateToNewPoint(-LANE_WIDTH, -LANE_BACK_EXTENT); cap0.x = newPoint.x; cap0.y = newPoint.y;
	translateToNewPoint(LANE_WIDTH, -LANE_BACK_EXTENT); cap1.x = newPoint.x; cap1.y = newPoint.y;
	drawLineInCostMap(cap0, cap1, BOUNDARY_COST, true);
	*/
}

bool initializeBoundaries()
{
	bool success = false;
	char *boundaryFileName = Data::getString("Boundary_File", success);
	if(success)
	{
		vector<double> latitudes, longitudes;
		std::string line;
		std::ifstream boundaryFile(boundaryFileName);
		if(!boundaryFile.is_open())
			return false;
		while(!boundaryFile.eof())
		{
			std::getline(boundaryFile, line);
			latitudes.push_back(atof(line.c_str()));
			if(boundaryFile.eof())
			{
				latitudes.pop_back();
				break;
			}
			getline(boundaryFile, line);
			longitudes.push_back(atof(line.c_str()));
		}
		for(int i = 0; i < (int)latitudes.size(); i++)
		{
			CartesianLocalPoint p = GPSTransforms::ConvertToLocal(GeodeticPoint(latitudes[i], longitudes[i]));
			latitudes[i] = p.X;
			longitudes[i] = p.Y;
		}
		
		for(int i = 0; i < latitudes.size(); i++)
		{
			/*
			double distance = wykobi::distance(latitudes[i], longitudes[i], latitudes[i+1], longitudes[i+1]);
			double numCells = distance / X_UNIT_SIZE;
			int numCellsI = (int)numCells;
			for(int j = 0; j <= numCellsI; j++)
			{
				double xCoord = latitudes[i] + (latitudes[i+1] - latitudes[i]) * (j / numCells);
				double yCoord = longitudes[i] + (longitudes[i+1] - longitudes[i]) * (j / numCells);
				boundaryXs.push_back(xCoord);
				boundaryYs.push_back(yCoord);
			}
			*/
			wykobi::point2d<> start, end;
			start.x = latitudes[i]; start.y = longitudes[i];
			end.x = latitudes[i+1==latitudes.size() ? 0 : i+1];
			end.y = longitudes[i+1==latitudes.size() ? 0 : i+1];
			cout << drawLineInCostMap(start, end, BOUNDARY_COST, true) << endl;
		}
		/*
		if(latitudes.size() > 2)
		{
			double distance = wykobi::distance(latitudes[latitudes.size() - 1], longitudes[latitudes.size() - 1], latitudes[0], longitudes[0]);
			double numCells = distance / X_UNIT_SIZE;
			int numCellsI = (int)numCells;
			for(int j = 0; j <= numCellsI; j++)
			{
				double xCoord = latitudes[latitudes.size() - 1] + (latitudes[0] - latitudes[latitudes.size() - 1]) * (j / numCells);
				double yCoord = longitudes[latitudes.size() - 1] + (longitudes[0] - longitudes[latitudes.size() - 1]) * (j / numCells);
				boundaryXs.push_back(xCoord);
				boundaryYs.push_back(yCoord);
			}
		}
		*/
		return true;
	}
	else return false;
}

void WaypointUpdateHandler(void *data)
{
    SetWaypointsType waypoints = *((SetWaypointsType*)data);
    if (waypoints.numPoints > 0)
	{
		waypoint.x = waypoints.points[0].x;
		waypoint.y = waypoints.points[0].y;
	}
}
//not currently called by anything
/*
void processValidLane(Lane lane, vector<Lane> &history)
{
	//Push onto vector as shift register
	for (int i = 1; i < history.size(); i++) history[i] = history[i-1];
	history[0] = lane;
	
	//Draw and persist the line.
	drawLineInCostMap(lane.start, lane.end, LANE_ADDED_COST, false);
	
	//Nonpersistent interpolation
	if(args->interpolateLanes && history.size() > 1)
		drawLineInCostMap(history[0].start, history[1].end, LANE_ADDED_COST, false);
	
	//Nonpersistent extrapolation
	/*
	if(args->extrapolate)
	{
		wykobi::point2d<> extra;
		//From wykobi::generate_point_on_ray
		extra.x = lane.start.x + LANE_EXTRAPOLATE_FACTOR * lane.end.x;
		extra.y = lane.start.y + LANE_EXTRAPOLATE_FACTOR * lane.end.y;
		drawLineInCostMap(lane.end, extra, LANE_ADDED_COST, false);
	}
	
}
*/
void StereoUpdateHandler(void *data)
{
	passID++;
	VisionUpdateType *update = (VisionUpdateType*)data;
	
	state = update->state;
	currentPosition.x = state.Easting;
	currentPosition.y = state.Northing;
	heading = -state.Heading * wykobi::_180DivPI;
	
	updateXs.clear();
	updateYs.clear();
	updateCosts.clear();

	if(!receivedStateEst)
	{
		receivedStateEst = true;
		//good idea, but not yet synchronized with nav in current implementation
//		costmap = new CostMap(state.Easting + X_MIN, state.Easting + X_MAX, state.Northing + Y_MIN, state.Northing + Y_MAX, X_UNIT_SIZE, Y_UNIT_SIZE);
//		persistentmap = new CostMap(state.Easting + X_MIN, state.Easting + X_MAX, state.Northing + Y_MIN, state.Northing + Y_MAX, X_UNIT_SIZE, Y_UNIT_SIZE);
		costmap = new CostMap(X_MIN, X_MAX, Y_MIN, Y_MAX, X_UNIT_SIZE, Y_UNIT_SIZE);
		persistentmap = new CostMap(X_MIN, X_MAX, Y_MIN, Y_MAX, X_UNIT_SIZE, Y_UNIT_SIZE);
		
		
		cmUpdate.xMax = costmap->getXMax();
		cmUpdate.xMin = costmap->getXMin();
		cmUpdate.xUnitSize = costmap->getXUnitSize();
		cmUpdate.yMax = costmap->getYMax();
		cmUpdate.yMin = costmap->getYMin();
		cmUpdate.yUnitSize = costmap->getYUnitSize();
		cout << "Received initial state estimation\n" << flush;
		cmUpdate.numPoints = 0;
		cmUpdate.xUpdates = NULL;
		cmUpdate.yUpdates = NULL;
		cmUpdate.costUpdates = NULL;
		//if (args->publish) 
			Messages::CostMap.publish(&cmUpdate);
		if(args->lanes) initializeLaneHistory();
		if(args->boundaries) initializeBoundaries();
	}

	double cost;
	void *stored;
	double stereomapval;
	int stuffIndex;

	// Clear out the segments
	for(int i = 0; i < SEGMENTS; i++)
		closestBlocked[i] = CLEAR_DISTANCE;

	// Clear the stereomap... why?
	// because stereomap is directly from the new updates?
	stereomap->setAll(CLEAR_COST);

	// Handle detected obstacles (directly from Kratos, refactored)
	for(int i = 0; i < update->numPoints; i++)
	{
		// Locate in the stereo map
		if(!stereomap->boundsCheck(update->xVals[i], update->yVals[i]))
			continue;

		stereomapval = stereomap->get(update->xVals[i], update->yVals[i]);
		if(stereomapval < OBSTACLE_COST + .0000001)
			stereomap->set(update->xVals[i], update->yVals[i], OBSTACLE_COST);
		else
			stereomap->set(update->xVals[i], update->yVals[i], stereomapval + ADDED_COST);
		stuffIndex = stereomap->getArrayIndex(update->xVals[i], update->yVals[i]);
		if(closestBlocked[stereomapStuff[stuffIndex].segment] < 0 || stereomapStuff[stuffIndex].distance <  closestBlocked[stereomapStuff[stuffIndex].segment])
		//stereomap->arrayY(update->yVals[i]) < closestBlocked[stereomapStuff[stuffIndex].segment])
		{
			closestBlocked[stereomapStuff[stuffIndex].segment] = stereomapStuff[stuffIndex].distance;
			stereomap->arrayY(update->yVals[i]);
		}
	}
#if 1
	
	//doesn't matter if initialLaneDetected=true; draw all splines on costmap regardless
	for (int i=0; i < update->nsplines; i++) {
		SplineIPC curr_spline=update->all_splines[i];
		for (int j=0; j < curr_spline.numcontrols - 1; j++) {

			//draw line segments between adjacent controls
			double x1=curr_spline.xcontrols[j];
			double y1=curr_spline.ycontrols[j];
			double x2=curr_spline.xcontrols[j+1];
			double y2=curr_spline.ycontrols[j+1];
			/*
			cout<<x1<<" "<<y1<<endl;
			if (j==curr_spline.numcontrols-2) cout<<x2<<" "<<y2<<endl;*/
			//translateToItself(x1,y1);
			//translateToItself(x2,y2);
			drawLine(*stereomap, wykobi::point2d<>(x1, y1), wykobi::point2d<>(x2, y2), LANE_ADDED_COST, true);
		}
	}
#endif
//if 0 to endif obsolete
#if 0
	if (initialLaneDetected) {
		// Handle lane points
		// second condition should always be true
		if(update->numLanes > 0 && update->numLanePoints == update->numLanes * 3)
		{
			for(int li = 0; li < update->numLanes; li++)
			{
				// read the endpoints and midpoint
				float *xVals = update->LanexVals + li*3;
				float *yVals = update->LaneyVals + li*3;
				double xValsD[3], yValsD[3];
				for(int i = 0; i < 3; i++) {
					xValsD[i] = (double) xVals[i] / 100.0;
					yValsD[i] = (double) yVals[i] / 100.0;
				}
				Polynomial<2> p = Polynomial<2>::findPoly(xValsD, yValsD);
				p.setTheta(-update->laneAngles[li]);
				p.setMinX(xValsD[0]);
				p.setMaxX(xValsD[2]);

				//either accept or reject lane based on heading continuity
				point2d newLaneHeading(xValsD[0] - xValsD[2], yValsD[0] - yValsD[2]);
				double crossProduct = newLaneHeading.x * currLaneHeading.x + newLaneHeading.y * currLaneHeading.y;
				if (crossProduct < HEADING_CONTINUITY)
					continue;
						
				//put polynomial into a buffer square region
				//laneStartPt.push_back(point2d(xValsD[0], yValsD[0]));
				//laneEndPt.push_back(point2d(xValsD[2], yValsD[2]));
				
				for(int i = 0; i < 2; i++) {
					double x1, y1, x2, y2;
					
					x1 = xValsD[i];
					y1 = yValsD[i];
					x2 = xValsD[i+1];
					y2 = yValsD[i+1];
					//p.evalRotated(xValsD[i], x1, y1);
					//p.evalRotated(xValsD[i + 1], x2, y2);
								
					translateToItself(x1, y1);
					translateToItself(x2, y2);
					drawLine(*costmap, wykobi::point2d<>(x1, y1), wykobi::point2d<>(x2, y2), LANE_ADDED_COST, true);
				}

				//remove lanes outside this region
				//TODO: !!!

				//test north
				drawLine(*costmap, wykobi::point2d<>(0, 0),
								  wykobi::point2d<>(0, 10),
								  LANE_ADDED_COST, true);

	/*			if(!stereomap->boundsCheck(update->LanexVals[i], update->LaneyVals[i]))
					continue;
				stereomapval = stereomap->get(update->LanexVals[i], update->LaneyVals[i]);
				stereomap->set(update->LanexVals[i], update->LaneyVals[i], stereomapval + LANE_ADDED_COST);
	*/
			}
		} else if (update->numLanes == 2) {  //possible initial lanes
			point2d laneHeading[2];
			point2d normLaneHeading[2];
			for (int li = 0; li <update->numLanes; ++li) {
				// read the endpoints and midpoint
				float *xVals = update->LanexVals + li*3;
				float *yVals = update->LaneyVals + li*3;
				double xValsD[3], yValsD[3];
				for(int i = 0; i < 3; i++) {
					xValsD[i] = (double) xVals[i] / 100.0;
					yValsD[i] = (double) yVals[i] / 100.0;
				}

				laneHeading[li].x = xValsD[0] - xValsD[2];
				laneHeading[li].y = yValsD[0] - yValsD[2];

				double d = sqrt(laneHeading[li].x * laneHeading[li].x + laneHeading[li].y * laneHeading[li].y);
				normLaneHeading[li].x = laneHeading[li].x / d;
				normLaneHeading[li].y = laneHeading[li].y / d;
			}
		
			double crossProduct = normLaneHeading[0].x * normLaneHeading[1].x + normLaneHeading[0].y * normLaneHeading[1].y;
			if (crossProduct > HEADING_CONTINUITY) {  //approximately parallel
				initialLaneDetected = true;
				cout << "Initial lanes found! crossProduct = " << crossProduct << endl;
			} else {
				cout << "Initial lanes not parallel! crossProduct = " << crossProduct << endl;
			}
			
			currLaneHeading.x = (laneHeading[0].x + laneHeading[1].x) / 2.0;
			currLaneHeading.y = (laneHeading[0].y + laneHeading[1].x) / 2.0;
		}

	}
#endif

	
	for(double y = STEREO_Y_MIN; y <= STEREO_Y_MAX + .0001; y += STEREO_Y_UNITSIZE)
	{
		int arrayY = stereomap->arrayY(y);
		for(double x  = firstInRow[arrayY]; x < lastInRow[arrayY] - .0001; x += STEREO_X_UNITSIZE)
			updateCostMapFromStereoMapPoint(x, y);
		for(double x  = secondFirstInRow[arrayY]; x < secondLastInRow[arrayY] - .0001; x += STEREO_X_UNITSIZE)
			updateCostMapFromStereoMapPoint(x, y);
	}

	
	updateCosts.reserve(updateXs.size());
	for(int i = 0; i < (int)updateXs.size(); i++)
		updateCosts.push_back(costmap->get(updateXs[i], updateYs[i]));

	for(int i = 0; i < boundaryXs.size(); i++)
	{
		updateXs.push_back(boundaryXs[i]);
		updateYs.push_back(boundaryYs[i]);
		updateCosts.push_back(BOUNDARY_COST);
	}

	if(updateXs.size() > 0)
	{
		cmUpdate.numPoints = (int)updateXs.size();
		cmUpdate.xUpdates = &updateXs[0];
		cmUpdate.yUpdates = &updateYs[0];
		cmUpdate.costUpdates = &updateCosts[0];
		//if (args->publish) 
		{
			Messages::CostMap.publish(&cmUpdate);
			cout << "Published " << cmUpdate.numPoints << " points.\n" << flush;
		}
	}
	
	/*
	//Waypoint generation
	if (args->generateWaypoints && args->lanes && update->numLanePoints > 0 &&
		!bestLeftLane.generated && !bestRightLane.generated &&
		((bestLeftLane.leftNiceness > NICENESS_THRESHOLD && 
		bestRightLane.rightNiceness > NICENESS_THRESHOLD) ||
		wykobi::distance(currentPosition, waypoint) < WAYPOINT_GEN_DISTANCE))
    {
		double wpheading = (bestLeftLane.heading + bestRightLane.heading) / 2.0;
		newPoint.x = currentPosition.x;
		newPoint.y = currentPosition.y + WAYPOINT_EXTENT;
		wykobi::point2d<> wp = wykobi::rotate(wpheading, newPoint, currentPosition);
		bool reachable = true; // is the waypoint reachable?
		int waypointxindex = costmap->arrayX(wp.x);
		int waypointyindex = costmap->arrayY(wp.y);
		for (int i = -WAYPOINT_RADIUS_TO_CLEAR; i <= WAYPOINT_RADIUS_TO_CLEAR; i++)
		{
			for (int j = -WAYPOINT_RADIUS_TO_CLEAR; j <= WAYPOINT_RADIUS_TO_CLEAR; j++)
			{
				if (!costmap->boundsCheckByIndex(waypointxindex+i, waypointyindex+j) ||
					costmap->getCell(waypointxindex+i, waypointyindex+j) != CLEAR_COST)
				{
					reachable = false;
					printf("Waypoint (%f, %f) unreachable.\n", wp.x, wp.y);
					break;
				}
			}
		}
		
		if (reachable)
		{
			waypoint = wp;
			printf("Set waypoint (%f, %f).\n", waypoint.x, waypoint.y);
		}
    }
	if (args->generateWaypoints && args->publish)
	{
		SetWaypointsType Waypoints;
		Waypoints.numPoints = 1;
		Pave_Libraries_Common::point2d pt;
		pt.x = waypoint.x;
		pt.y = waypoint.y;
		Waypoints.points = &pt;
		Messages::SetWaypoints.publish(&Waypoints);
	}
	*/
}

void ClearCostMapHandler(void *data)
{
    costmap->setAll(CLEAR_COST);

	updateXs.clear();
	updateYs.clear();
	updateCosts.clear();

	if(args->boundaries) initializeBoundaries();
	
	updateCosts.reserve(updateXs.size());
	for(int i = 0; i < (int)updateXs.size(); i++)
		updateCosts.push_back(costmap->get(updateXs[i], updateYs[i]));

	for(int i = 0; i < boundaryXs.size(); i++)
	{
		updateXs.push_back(boundaryXs[i]);
		updateYs.push_back(boundaryYs[i]);
		updateCosts.push_back(BOUNDARY_COST);
	}

	if(updateXs.size() > 0)
	{
		cmUpdate.numPoints = (int)updateXs.size();
		cmUpdate.xUpdates = &updateXs[0];
		cmUpdate.yUpdates = &updateYs[0];
		cmUpdate.costUpdates = &updateCosts[0];
		//if (args->publish) 
		{
			Messages::CostMap.publish(&cmUpdate);
			cout << "Published " << cmUpdate.numPoints << " points.\n" << flush;
		}
	}
}

int main(int argc, char **argv)
{
	args = parseArgs(argc, argv);

	initializeStereoMap();
	IPCConnect("CostMapGenerator");
	Messages::VisionUpdate.subscribe(&StereoUpdateHandler, true, false);
    if (!args->generateWaypoints)
        Messages::SetWaypoints.subscribe(&WaypointUpdateHandler, true, false);
    Messages::ClearCostMap.subscribe(&ClearCostMapHandler, true, false);
	//Messages::StateEstimation.subscribe(&SEUpdateHandler, true, false);
	//Initial state estimation is now part of StereoUpdateHandler

	IPC_dispatch();
}